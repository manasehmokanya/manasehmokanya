'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var loaderUtils = _interopDefault(require('loader-utils'));
var validateOptions = _interopDefault(require('schema-utils'));
var SingleEntryPlugin = _interopDefault(require('webpack/lib/SingleEntryPlugin'));
var WebWorkerTemplatePlugin = _interopDefault(require('webpack/lib/webworker/WebWorkerTemplatePlugin'));

function serviceWorker(publicPath, file) {
	return `

export class ServiceWorkerNoSupportError extends Error {

	constructor() {
		super('ServiceWorker is not supperted.');
	}
}

export default function registerServiceWorkerIfSupported(options) {

	if ('serviceWorker' in navigator) {
		return navigator.serviceWorker.register(${publicPath} + ${file}, options);
	}

	return Promise.reject(new ServiceWorkerNoSupportError());
}

`;
}
module.exports = exports["default"];

class LoaderError extends Error {

	constructor(err) {

		super(err);

		this.name = err.name || 'Loader Error';
		this.message = `${err.name}\n\n${err.message}\n`;
		this.stack = false;
	}
}
module.exports = exports['default'];

const type = "object";
const properties = { "filename": { "type": "string" }, "publicPath": { "type": "string" }, "outputPath": { "type": "string" } };
const additionalProperties = false;
var schema = {
	type: type,
	properties: properties,
	additionalProperties: additionalProperties
};

function loader() {}

loader.pitch = function pitch(request) {

	const options = loaderUtils.getOptions(this) || {};

	validateOptions(schema, options, 'ServiceWorker Loader');

	if (!this.webpack) {
		throw new LoaderError({
			name: 'ServiceWorker Loader',
			message: 'This loader is only usable with webpack'
		});
	}

	this.cacheable(false);

	const cb = this.async();

	const filename = loaderUtils.interpolateName(this, options.filename || '[name].js', {
		context: options.context || this.rootContext || this.options.context,
		regExp: options.regExp
	});

	const publicPath = options.publicPath || '/';

	const outputOptions = {
		filename,
		chunkFilename: `[id].${filename}`,
		namedChunkFilename: null
	};

	// TODO remove and triage eventual replacement via an option if needed
	// doesn't work with webpack > v2.0.0
	if (this.options && this.options.worker && this.options.worker.output) {
		Object.keys(this.options.worker.output).forEach(name => {
			outputOptions[name] = this.options.worker.output[name];
		});
	}

	const compiler = this._compilation.createChildCompiler('service-worker', outputOptions);

	compiler.apply(new WebWorkerTemplatePlugin(outputOptions));
	compiler.apply(new SingleEntryPlugin(this.context, `!!${request}`, 'main'));

	// TODO remove and triage eventual replacement via an option if needed
	// doesn't work with webpack > v2.0.0
	if (this.options && this.options.worker && this.options.worker.plugins) {
		this.options.worker.plugins.forEach(plugin => compiler.apply(plugin));
	}

	const subCache = `subcache ${__dirname} ${request}`;

	compiler.plugin('compilation', compilation => {

		if (compilation.cache) {

			if (!compilation.cache[subCache]) {
				compilation.cache[subCache] = {};
			}

			compilation.cache = compilation.cache[subCache];
		}
	});

	const rootCompiler = this._compiler,
	      fs = rootCompiler.outputFileSystem;

	compiler.runAsChild((err, entries) => {

		if (err) {
			return cb(err);
		}

		if (entries[0]) {

			const file = entries[0].files[0];

			if (options.outputPath) {

				rootCompiler.plugin('after-emit', (compilation, callback) => {

					const asset = compilation.assets[file];

					fs.unlink(asset.existsAt, err => {

						if (err) {
							return callback(err);
						}

						return fs.writeFile(path.join(options.outputPath, file), asset.source(), 'utf8', err => callback(err));
					});
				});
			}

			const code = serviceWorker(JSON.stringify(publicPath) || '__webpack_public_path__', JSON.stringify(file));

			return cb(null, code);
		}

		return cb(null, null);
	});
};
module.exports = exports['default'];

module.exports = loader;
//# sourceMappingURL=index.js.map
